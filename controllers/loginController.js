import jwt from 'jsonwebtoken';
import prisma from "../models/prisma";
import bcrypt from 'bcrypt';
import fs from 'fs';
import path from 'path';

const getPageLogin = async (req, res) => {
  res.clearCookie("jwt");
  if (typeof req.session === "undefined") {
    return res.render("page-login");
  } else {
    const info = req.session.info;
    delete req.session.info;
    const brokenAuthenStatus = await prisma.vulnSetting.findUnique({
      where: {
        name: "Broken Authentication"
      }
    })
    if(brokenAuthenStatus.status === "No") {
      await prisma.credential.update({
        where: {
          username: 'admin',
        },
        data: {
          password: '$2a$10$h1Y/K1U.SLa.3gRsIHj6M.5.urnvzkQoK8O70or2s59Y3oTHoKZq.'
        }
      })
    }
    else {
      await prisma.credential.update({
        where: {
          username: 'admin',
        },
        data: {
          password: '$2a$10$ZJZ8VybAy3QKwI3wWlC7DevGQz8XMqkI2Eau61cjN5vw6Uazf4/EO'
        }
      })
    }
    return res.render("page-login", { info: info });
  }
};

const handleLogin = async (req, res) => {
  const { username, password } = req.body;
  try {
    let result;

    // Check SQLI status
    const SQLIstatus = await prisma.vulnSetting.findUnique({
      where: {
        name: "SQLI"
      }
    });
    if (SQLIstatus.status === 'Login') {
      const blacklist = ['--', '#', '/**/', 'or', 'Or', 'oR', 'OR'];
      const isBlacklisted = blacklist.some(char => username.includes(char) || password.includes(char));
    
      if (isBlacklisted) {
        const error = {
          message: "Do not hack!!!"
        };
        return res.render('page-login', { layout: false, error: error });
      }
    
      result = await prisma.$queryRawUnsafe(`SELECT * FROM "Credential" WHERE username='${username}'`);
    }    
    else { 
      result = await prisma.$queryRaw`SELECT * FROM "Credential" where username=${username}`;
    }

    if (result.length == 0 || !await bcrypt.compare(password, result[0].password)) {
      const error = {
        message: "Username or Password is incorrect !"
      };
      const brokenAuthenStatus = await prisma.vulnSetting.findUnique({
        where: {
          name: "Broken Authentication"
        }
      })
      if(brokenAuthenStatus.status === "Block IP") {
        let ipUser = await prisma.failLogin.findUnique({
          where: {
            ip: req.ip
          }
        })
        const offsetHours = 7; 
        const now = new Date();
        const utcDate = new Date(now.getTime() + offsetHours * 60 * 60 * 1000);
        const timestampISO = utcDate.toISOString();
        if(ipUser == null) {
          ipUser = await prisma.failLogin.create({
            data: {
              ip: req.ip,
              count: 1,
              lockUntil: timestampISO
            }
          })
        }
        else {
          await prisma.failLogin.update({
            where: {
              ip: req.ip
            },
            data: {
              count: ipUser.count + 1
            }
          })
          if(ipUser.count + 1 >= process.env.MAX_FAIL_LOGIN){
            const lockTime = new Date(now.getTime() + offsetHours * 60 * 60 * 1000 + 1 * 60 * 1000);
            const locktimestampISO = lockTime.toISOString();
            await prisma.failLogin.update({
              where: {
                ip: req.ip
              },
              data: {
                lockUntil: locktimestampISO,
                count: 0
              }
            })
            return res.render('page-login', { layout: false, error: { message: `Try again after 60 seconds!` } });
          }       
        }
      }
      else if(brokenAuthenStatus.status === "Block Account") {
        let ipUser = await prisma.failLogin.findUnique({
          where: {
            ip: username
          }
        })
        const offsetHours = 7; 
        const now = new Date();
        const utcDate = new Date(now.getTime() + offsetHours * 60 * 60 * 1000);
        const timestampISO = utcDate.toISOString();
        if(ipUser == null) {
          ipUser = await prisma.failLogin.create({
            data: {
              ip: username,
              count: 1,
              lockUntil: timestampISO
            }
          })
        }
        else {
          await prisma.failLogin.update({
            where: {
              ip: username
            },
            data: {
              count: ipUser.count + 1
            }
          })
          if(ipUser.count + 1 >= process.env.MAX_FAIL_LOGIN){
            const lockTime = new Date(now.getTime() + offsetHours * 60 * 60 * 1000 + 5 * 60 * 1000);
            const locktimestampISO = lockTime.toISOString();
            await prisma.failLogin.update({
              where: {
                ip: username
              },
              data: {
                lockUntil: locktimestampISO,
                count: 0
              }
            })
            return res.render('page-login', { layout: false, error: { message: `Blocked username: ${username}. Try again after 5 minutes!` } });
          }       
        }
      }
      return res.render('page-login', { layout: false, error: error });
    }
    else{
      const ipUser = await prisma.failLogin.findUnique({
        where: {
          ip: req.ip
        }
      })
      if(ipUser != null){
        await prisma.failLogin.delete({
          where: {
            ip: req.ip
          }
        })
      }
    }
    let header;
    const jwtStatus = await prisma.vulnSetting.findUnique({
      where: {
        name: "JWT"
      }
    });
    let key;
    if (jwtStatus.status === "Algo-Confusion" || jwtStatus.status === "No") {
      header = {
        alg: 'RS256',
        typ: 'JWT',
        kid: "fbdafd16-cc6a-4e21-8924-6531343f7a49"
      };
      key = fs.readFileSync(path.join(__dirname, "../helper/key/privateKey.pem"), 'utf-8');
    } else if (jwtStatus.status === "None-Alg") {
      header = {
        alg: 'HS256',
        typ: 'JWT',
      };
    }
    let token;
    if (jwtStatus.status === "Algo-Confusion" || jwtStatus.status === "No") {
      token = jwt.sign(
        { id: result[0].id, username: username, isAdmin: false },
        key,
        { algorithm: 'RS256', header }
      );
    } else if (jwtStatus.status === "Weak-Key") {
      header = {
        alg: 'HS256',
        typ: 'JWT',
      };

      const secretsFilePath = path.join(__dirname, '../helper/key/jwt.txt');
      const secrets = fs.readFileSync(secretsFilePath, 'utf8').split('\n').filter(secret => secret.trim() !== '');

      const randomIndex = Math.floor(Math.random() * secrets.length);
      const jwtsecret = secrets[randomIndex];
      const usedSecretsFilePath = path.join(__dirname, '../helper/key/used_jwt.txt');
      fs.writeFileSync(usedSecretsFilePath, jwtsecret);

      token = jwt.sign(
        { id: result[0].id, username: username},
        jwtsecret,
        { expiresIn: '1h', header }
      );
    } else {
      token = jwt.sign(
        { id: result[0].id, username: username},
        process.env.JWT_SECRET,
        { expiresIn: '5d', header }
      );
    }

    res.cookie("jwt", token, {
      httpOnly: true,
      maxAge: 10000 * 1000
    });

    return res.redirect("/");
  } catch (error) {
    res.render("page-login", { error: { message: error.message } });
  }
};

export default {
  getPageLogin,
  handleLogin
};
